# -*- coding: utf-8 -*-
import base64
import json
import socket
import os
import sys
import threading
import concurrent.futures
import requests
import shutil
import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog, messagebox
from urllib.parse import urlparse
from datetime import datetime
import time
import webbrowser
import gzip
import tarfile
import yaml
import re  # æ­£åˆ™è¡¨è¾¾å¼æ¨¡å—
# === æ ¸å¿ƒä¾èµ–æ£€æŸ¥ ===
HAS_GEOIP = False
try:
import geoip2.database
HAS_GEOIP = True
except ImportError:
pass
def get_base_path():
if getattr(sys, 'frozen', False): return os.path.dirname(os.path.abspath(sys.executable))
return os.path.dirname(os.path.abspath(__file__))
BASE_DIR = get_base_path()
NODES_DIR = os.path.join(BASE_DIR, "nodes")
GEO_DIR = os.path.join(BASE_DIR, "GeoLite")
LOG_DIR = os.path.join(BASE_DIR, "log")
DEFAULT_NODES = os.path.join(NODES_DIR, "nodes.txt")
DEFAULT_MMDB = os.path.join(GEO_DIR, "GeoLite2-Country.mmdb")
CONFIG_FILE = os.path.join(BASE_DIR, "config.json")
VERSION = "v1.2æ­£å¼ç‰ˆ"
APP_NAME = "èŠ‚ç‚¹ç›’å­"
for folder in ["log", "GeoLite", "nodes"]:
os.makedirs(os.path.join(BASE_DIR, folder), exist_ok=True)
from ctypes import windll
windll.shcore.SetProcessDpiAwareness(1)
except: pass
COUNTRY_MAP = {
"CN": "ä¸­å›½", "HK": "é¦™æ¸¯", "TW": "å°æ¹¾", "MO": "æ¾³é—¨", "JP": "æ—¥æœ¬",
"KR": "éŸ©å›½", "SG": "æ–°åŠ å¡", "US": "ç¾å›½", "CA": "åŠ æ‹¿å¤§", "GB": "è‹±å›½",
"FR": "æ³•å›½", "DE": "å¾·å›½", "IT": "æ„å¤§åˆ©", "RU": "ä¿„ç½—æ–¯", "IN": "å°åº¦",
"AU": "æ¾³å¤§åˆ©äºš", "NL": "è·å…°", "PH": "è²å¾‹å®¾", "TH": "æ³°å›½", "MY": "é©¬æ¥è¥¿äºš",
"VN": "è¶Šå—", "ID": "å°å°¼", "BR": "å·´è¥¿", "AR": "é˜¿æ ¹å»·", "TR": "åœŸè€³å…¶",
"ES": "è¥¿ç­ç‰™", "PT": "è‘¡è„ç‰™", "SE": "ç‘å…¸", "NO": "æŒªå¨", "MX": "å¢¨è¥¿å“¥"
}
class NodeboxGUI:
def __init__(self, root):
self.root = root
self.root.title(f"{APP_NAME} {VERSION}")
self.root.geometry("1100x1100")
self.is_paused = False
self.stop_requested = False
self.force_stop = False
self.pause_cond = threading.Condition()
self.valid_nodes = []
self.gemini_nodes = []
self.source_mode = tk.IntVar(value=0)
self.current_out_folder = ""
self.all_interactive_btns = []
self.executor = None
# --- åŠŸèƒ½å‹¾é€‰å˜é‡ ---
self.opt_dedup = tk.BooleanVar(value=True)
self.opt_tag = tk.BooleanVar(value=True)
self.opt_test = tk.BooleanVar(value=True)
self.v2rayn_path = tk.StringVar()
self.clash_path = tk.StringVar()
self.appbox_path = tk.StringVar()
self.sub_url = tk.StringVar()
self.db_url = tk.StringVar()
self.sub_sources = tk.StringVar()
self.g_repo = tk.StringVar()
self.g_token = tk.StringVar()
self.gh_repo = tk.StringVar()
self.gh_token = tk.StringVar()
self.stat_total = tk.StringVar(value="è¯»å–èŠ‚ç‚¹ï¼š0")
self.stat_dup = tk.StringVar(value="å»é‡èŠ‚ç‚¹ï¼š0")
self.stat_fail = tk.StringVar(value="æµ‹è¯•å‰”é™¤ï¼š0")
self.stat_final = tk.StringVar(value="æœ‰æ•ˆèŠ‚ç‚¹ï¼š0")
self.stat_gemini = tk.StringVar(value="GeminièŠ‚ç‚¹ï¼š0")
# æ–‡ä»¶ç”Ÿæˆé€‰é¡¹
self.file_vars = {
"all_nodes.txt": tk.BooleanVar(value=True),
"valid_nodes.txt": tk.BooleanVar(value=True),
"valid_nodes.yaml": tk.BooleanVar(value=True),
"gemini.txt": tk.BooleanVar(value=True)
# æ–‡ä»¶æ˜¾ç¤ºåç§°æ˜ å°„
self.file_display_names = {
"all_nodes.txt": "all_nodes.txt",
"valid_nodes.txt": "valid_nodes.txt",
"valid_nodes.yaml": "valid_nodes.yaml",
"gemini.txt": "geminiä¸“ç”¨"
self.setup_ui()
self.load_config()
self.refresh_file_status()
def log(self, m, color="normal"):
"""è®°å½•æ—¥å¿—ï¼Œæ”¯æŒé¢œè‰²æ ‡è®°"""
ts = datetime.now().strftime('%H:%M:%S')
full_msg = f"[{ts}] {m}\n"
# æ’å…¥å¸¦é¢œè‰²çš„æ–‡æœ¬
self.log_area.insert(tk.END, f"[{ts}] ")
if color == "success":
self.log_area.insert(tk.END, m + "\n", "green")
elif color == "error":
self.log_area.insert(tk.END, m + "\n", "red")
elif color == "warning":
self.log_area.insert(tk.END, m + "\n", "orange")
else:
self.log_area.insert(tk.END, m + "\n")
self.log_area.see(tk.END)
with open(os.path.join(LOG_DIR, f"log_{datetime.now().strftime('%Y%m%d')}.log"), "a", encoding="utf-8") as f:
f.write(full_msg)
def setup_ui(self):
sf = ttk.LabelFrame(self.root, text=" âš™ï¸ æ•°æ®æºé…ç½® ")
sf.pack(fill="x", padx=15, pady=5)
sf.columnconfigure(1, weight=1)
ttk.Label(sf, text="è¯»å–æº:").grid(row=0, column=0, padx=10, pady=10, sticky="w")
rb_f = ttk.Frame(sf)
rb_f.grid(row=0, column=1, columnspan=2, sticky="w")
r1 = ttk.Radiobutton(rb_f, text="ä»æœ¬åœ°æ–‡ä»¶è¯»å–", variable=self.source_mode, value=0, command=self.save_config)
r1.pack(side="left", padx=5)
self.all_interactive_btns.append(r1)
r2 = ttk.Radiobutton(rb_f, text="ä»å‰ªè´´æ¿è¯»å–", variable=self.source_mode, value=1, command=self.save_config)
r2.pack(side="left", padx=5)
self.all_interactive_btns.append(r2)
ttk.Label(sf, text="èŠ‚ç‚¹æ–‡ä»¶:").grid(row=1, column=0, padx=10, pady=5, sticky="w")
self.ent_node = ttk.Entry(sf)
self.ent_node.grid(row=1, column=1, padx=5, pady=5, sticky="ew")
nb = ttk.Frame(sf); nb.grid(row=1, column=2, padx=10)
btn_sel_n = ttk.Button(nb, text="æµè§ˆæœ¬åœ°", width=10, command=self.select_nodes)
btn_sel_n.pack(side="left", padx=2)
self.btn_sub_upd = ttk.Button(nb, text="è¿œç¨‹é‡‡é›†", width=10, command=self.remote_collect_nodes)
self.btn_sub_upd.pack(side="left", padx=2)
self.all_interactive_btns.extend([btn_sel_n, self.btn_sub_upd])
self.lbl_node_info = ttk.Label(sf, text="æ£€æŸ¥ä¸­...", font=("å¾®è½¯é›…é»‘", 8))
self.lbl_node_info.grid(row=2, column=1, sticky="w", padx=5)
ttk.Label(sf, text="IPæ•°æ®åº“:").grid(row=3, column=0, padx=10, pady=5, sticky="w")
self.ent_db = ttk.Entry(sf)
self.ent_db.grid(row=3, column=1, padx=5, pady=5, sticky="ew")
dbb = ttk.Frame(sf); dbb.grid(row=3, column=2, padx=10)
btn_sel_db = ttk.Button(dbb, text="æµè§ˆæœ¬åœ°", width=10, command=self.select_db)
btn_sel_db.pack(side="left", padx=2)
self.btn_db_upd = ttk.Button(dbb, text="è¿œç¨‹ä¸‹è½½", width=10, command=lambda: self.remote_sync_act("db"))
self.btn_db_upd.pack(side="left", padx=2)
self.all_interactive_btns.extend([btn_sel_db, self.btn_db_upd])
self.lbl_db_info = ttk.Label(sf, text="æ£€æŸ¥ä¸­...", font=("å¾®è½¯é›…é»‘", 8))
self.lbl_db_info.grid(row=4, column=1, sticky="w", padx=5, pady=(0, 10))
# --- åŠŸèƒ½å¯é€‰å¼€å…³åŒº ---
of = ttk.LabelFrame(self.root, text="âš™ï¸ ç­›é€‰é¡¹è‡ªå®šä¹‰ ")
of.pack(fill="x", padx=15, pady=5)
ttk.Checkbutton(of, text="èŠ‚ç‚¹å»é‡å¤", variable=self.opt_dedup).pack(side="left", padx=20, pady=10)
ttk.Checkbutton(of, text="å›½å®¶ç è¯†åˆ«", variable=self.opt_tag).pack(side="left", padx=20, pady=10)
ttk.Checkbutton(of, text="çœŸè¿æ¥æµ‹è¯•", variable=self.opt_test).pack(side="left", padx=20, pady=10)
# --- æŒ‰é’®å¼€å…³ ---
ctrl = ttk.Frame(self.root); ctrl.pack(fill="x", padx=15, pady=5)
self.btn_start = ttk.Button(ctrl, text="ğŸš€ å¯åŠ¨", command=self.start_task)
self.btn_start.pack(side="left", fill="x", expand=True, padx=2)
self.btn_pause = ttk.Button(ctrl, text="â¸ æš‚åœ", command=self.toggle_pause, state="disabled")
self.btn_pause.pack(side="left", fill="x", expand=True, padx=2)
self.btn_stop = ttk.Button(ctrl, text="â¹ ç»ˆæ­¢", command=self.on_stop_click, state="disabled")
self.btn_stop.pack(side="left", fill="x", expand=True, padx=2)
mf = ttk.Frame(self.root)
mf.pack(fill="x", padx=15, pady=5)
mf.columnconfigure(0, weight=1)
mf.columnconfigure(1, weight=1)
mf.columnconfigure(2, weight=2)
self.box_stat = ttk.LabelFrame(mf, text=" æ•°æ®ç»Ÿè®¡ ")
self.box_stat.grid(row=0, column=0, sticky="nsew", padx=(0,5))
si = ttk.Frame(self.box_stat, padding=10); si.pack(fill="both", expand=True)
ttk.Label(si, textvariable=self.stat_total).pack(anchor="w", pady=4)
ttk.Label(si, textvariable=self.stat_dup).pack(anchor="w", pady=4)
ttk.Label(si, textvariable=self.stat_fail).pack(anchor="w", pady=4)
ttk.Label(si, textvariable=self.stat_final, foreground="#28a745", font=("å¾®è½¯é›…é»‘", 9, "bold")).pack(anchor="w", pady=4)
ttk.Label(si, textvariable=self.stat_gemini, foreground="#17a2b8", font=("å¾®è½¯é›…é»‘", 9, "bold")).pack(anchor="w", pady=4)
ai = ttk.LabelFrame(mf, text=" è®¾ç½®ä¸­å¿ƒ ")
ai.grid(row=0, column=1, sticky="nsew", padx=5)
b_set = ttk.Button(ai, text="âš™ï¸ æˆ‘çš„è®¾ç½®", width=15, command=self.open_settings)
b_set.pack(pady=4, padx=10, anchor="w")
b_appbox = ttk.Button(ai, text="ğŸ“¦ AIç›’å­", width=15, command=self.open_appbox)
b_appbox.pack(pady=4, padx=10, anchor="w")
b_v2 = ttk.Button(ai, text="ğŸ“‚ v2rayN ", width=15, command=self.open_v2rayn)
b_v2.pack(pady=4, padx=10, anchor="w")
b_cl = ttk.Button(ai, text="ğŸ“‚ ClashV ", width=15, command=self.open_clash)
b_cl.pack(pady=4, padx=10, anchor="w")
self.all_interactive_btns.extend([b_set, b_appbox, b_v2, b_cl])
self.box_file = ttk.LabelFrame(mf, text=" ç”Ÿæˆä»¥ä¸‹æ–‡ä»¶ ")
self.box_file.grid(row=0, column=2, sticky="nsew", padx=(5,0))
fi = ttk.Frame(self.box_file, padding=10); fi.pack(fill="both")
self.file_btns_refs = []
for i, (file_name, display_name) in enumerate(self.file_display_names.items()):
ttk.Checkbutton(fi, text=display_name, variable=self.file_vars[file_name]).grid(row=i, column=0, sticky="w", pady=2)
# æ¨é€æŒ‰é’®ï¼ˆå·¦è¾¹ï¼‰
bp = ttk.Button(fi, text="æ¨é€", width=5, state="disabled")
bp.config(command=lambda f=file_name, b=bp: self.manual_push(f, b))
bp.grid(row=i, column=1, padx=2)
self.file_btns_refs.append(bp)
# å¤åˆ¶æŒ‰é’®ï¼ˆå³è¾¹ï¼‰- valid_nodes.yamlæ²¡æœ‰å¤åˆ¶æŒ‰é’®
if file_name != "valid_nodes.yaml":
bc = ttk.Button(fi, text="å¤åˆ¶", width=5, state="disabled")
bc.config(command=lambda f=file_name, b=bc: self.copy_act(f, b))
bc.grid(row=i, column=2, padx=2)
self.file_btns_refs.append(bc)
btn_frame = ttk.Frame(fi); btn_frame.grid(row=0, column=3, rowspan=6, padx=10, sticky="ns")
self.btn_open_folder = ttk.Button(btn_frame, text="ğŸ“ æ‰“å¼€", width=8, state="disabled", command=self.open_current_folder)
self.btn_open_folder.pack(pady=2)
self.btn_push_all = ttk.Button(btn_frame, text="å…¨éƒ¨æ¨é€", width=8, state="disabled", command=self.push_all_files)
self.btn_push_all.pack(pady=2)
self.btn_gitee = ttk.Button(btn_frame, text="Gitee", width=8, command=lambda: self.open_url("gitee"))
self.btn_gitee.pack(pady=2)
self.btn_github = ttk.Button(btn_frame, text="GitHub", width=8, command=lambda: self.open_url("github"))
self.btn_github.pack(pady=2)
self.all_interactive_btns.extend([self.btn_open_folder, self.btn_push_all, self.btn_gitee, self.btn_github])
self.progress = ttk.Progressbar(self.root, orient="horizontal", mode="determinate")
self.progress.pack(fill="x", padx=15, pady=5)
status_bar = ttk.Frame(self.root); status_bar.pack(fill="x", padx=15)
self.lbl_percent = ttk.Label(status_bar, text="0%", width=6); self.lbl_percent.pack(side="left")
btn_about = ttk.Button(status_bar, text="å…³äºç¨‹åºâ“ ", width=12, command=self.show_about)
btn_about.pack(side="right", pady=2); self.all_interactive_btns.append(btn_about)
self.log_area = scrolledtext.ScrolledText(self.root, wrap=tk.WORD, font=("Consolas", 10), height=15)
self.log_area.pack(fill="both", expand=True, padx=15, pady=5)
# é…ç½®æ–‡æœ¬é¢œè‰²æ ‡ç­¾
self.log_area.tag_config("green", foreground="green")
self.log_area.tag_config("red", foreground="red")
self.log_area.tag_config("orange", foreground="orange")
def start_task(self):
if self.opt_tag.get() and not HAS_GEOIP:
messagebox.showerror("ä¾èµ–ç¼ºå¤±", "æœªæ£€æµ‹åˆ° geoip2 æ¨¡å—ã€‚è¯·åœ¨ç»ˆç«¯æ‰§è¡Œï¼š\npip install geoip2")
return
# æ£€æŸ¥IPæ•°æ®åº“æ˜¯å¦è¶…è¿‡30å¤©
if self.opt_tag.get():
p_db = self.ent_db.get().strip()
if os.path.exists(p_db):
mtime = os.path.getmtime(p_db)
days = (time.time() - mtime) / (24 * 3600)
if days > 30:
self.log("âš ï¸ IPæ•°æ®åº“å·²è¶…è¿‡30å¤©ï¼Œæ­£åœ¨è‡ªåŠ¨æ›´æ–°...", "warning")
self.auto_update_db()
self.log("âŒ å¯åŠ¨å¤±è´¥ï¼šç”±äºå¼€å¯äº†å›½å®¶ç è¯†åˆ«ï¼Œå¿…é¡»æä¾›åœ°å€åº“æ–‡ä»¶ã€‚", "error")
p_node = self.ent_node.get().strip()
selected_files = {file_name: var.get() for file_name, var in self.file_vars.items()}
if self.opt_tag.get() and not os.path.exists(p_db):
self.lock_all_ui()
self.btn_pause.config(state="normal", text="â¸ æš‚åœ")
self.btn_stop.config(state="normal", text="â¹ ç»ˆæ­¢")
self.valid_nodes, self.gemini_nodes, self.stop_requested, self.is_paused = [], [], False, False
self.log_area.delete(1.0, tk.END)
self.log("ğŸš€ å¯åŠ¨è‡ªåŠ¨åŒ–å·¥ä½œæµ...")
raw_data = ""
if self.source_mode.get() == 0:
if not os.path.exists(p_node):
self.log(f"âŒ æ‰¾ä¸åˆ°èŠ‚ç‚¹æ–‡ä»¶: {p_node}", "error")
self.reset_ui()
with open(p_node, 'r', encoding='utf-8', errors='ignore') as f:
raw_data = f.read()
raw_data = self.root.clipboard_get().strip()
except:
self.log("âŒ å‰ªåˆ‡æ¿ä¸ºç©º", "error")
if not raw_data:
self.log("âŒ æ— æ•ˆçš„æ•°æ®æº", "error")
threading.Thread(target=self.run_process, args=(raw_data, p_db, selected_files), daemon=True).start()
except Exception as e:
self.log(f"ğŸ’¥ å¯åŠ¨å¼‚å¸¸: {e}", "error")
def auto_update_db(self):
"""è‡ªåŠ¨æ›´æ–°è¶…è¿‡30å¤©çš„IPæ•°æ®åº“"""
def _update():
url = self.db_url.get().strip()
if not url:
self.log("âŒ æ— æ³•è‡ªåŠ¨æ›´æ–°ï¼šæœªé…ç½®IPåº“URL", "error")
self.root.after(0, self.reset_ui)
self.log("ğŸ”§ æ­£åœ¨è‡ªåŠ¨æ›´æ–°IPæ•°æ®åº“...")
final_path = DEFAULT_MMDB
temp_path = final_path + ".tmp"
r = requests.get(url, timeout=60, stream=True)
r.raise_for_status()
total = int(r.headers.get('content-length', 0))
dl = 0
with open(temp_path, "wb") as f:
for chunk in r.iter_content(chunk_size=16384):
if chunk:
f.write(chunk)
dl += len(chunk)
if total > 0:
p = int(dl/total*100)
self.root.after(0, lambda v=p: [
self.progress.configure(value=v),
self.lbl_percent.config(text=f"{v}%")
])
if ".tar.gz" in url:
with tarfile.open(temp_path, "r:gz") as tar:
for m in tar.getmembers():
if m.name.endswith(".mmdb"):
m.name = os.path.basename(m.name)
tar.extract(m, GEO_DIR)
if os.path.exists(final_path): os.remove(final_path)
os.rename(os.path.join(GEO_DIR, m.name), final_path)
elif ".gz" in url:
with gzip.open(temp_path, 'rb') as f_in, open(final_path, 'wb') as f_out:
shutil.copyfileobj(f_in, f_out)
shutil.move(temp_path, final_path)
if os.path.exists(temp_path): os.remove(temp_path)
self.log("âœ… IPæ•°æ®åº“è‡ªåŠ¨æ›´æ–°å®Œæˆ", "success")
self.root.after(0, self.refresh_file_status)
self.root.after(1000, self.start_task)
self.log(f"âŒ IPæ•°æ®åº“è‡ªåŠ¨æ›´æ–°å¤±è´¥: {e}", "error")
finally:
self.root.after(0, lambda: [
self.progress.configure(value=0),
self.lbl_percent.config(text="0%")
threading.Thread(target=_update, daemon=True).start()
def get_country_tag(self, host, reader):
"""è·å–å›½å®¶æ ‡ç­¾"""
ip_addr = socket.gethostbyname(host)
res = reader.country(ip_addr)
iso = res.country.iso_code
cname = COUNTRY_MAP.get(iso, "æœªçŸ¥")
return f"{iso.lower()}{cname}"
return "unæœªçŸ¥"
def decode_base64_content(self, content):
"""å°è¯•è§£ç base64å†…å®¹"""
content = content.strip()
# å°è¯•è§£ç 
decoded = base64.b64decode(content + '=' * (-len(content) % 4)).decode('utf-8')
return decoded
return content
def run_process(self, raw, db_p, selected_files):
"""ä¸»å¤„ç†æµç¨‹"""
if self.stop_requested:
self.root.after(0, lambda: self.log("â¹ ä»»åŠ¡å·²æ‰‹åŠ¨åœæ­¢", "warning"))
out_folder = os.path.join(NODES_DIR, datetime.now().strftime("%Y%m%d_%H%M%S"))
os.makedirs(out_folder, exist_ok=True)
self.current_out_folder = out_folder
self.log(f"ğŸ“ ç»“æœå°†ä¿å­˜åˆ°: {out_folder}")
# ========== æ­¥éª¤1: è¯»å–å¹¶è§£ç èŠ‚ç‚¹ ==========
self.log("ğŸ“ æ­¥éª¤1: æ­£åœ¨è¯»å–å¹¶è§£ç èŠ‚ç‚¹...")
self.progress.configure(value=10),
self.lbl_percent.config(text="10%")
raw = self.decode_base64_content(raw)
raw_nodes = [line.strip() for line in raw.split('\n') if line.strip()]
self.log(f"âœ… æ­¥éª¤1å®Œæˆ: è¯»å–åˆ° {len(raw_nodes)} ä¸ªåŸå§‹èŠ‚ç‚¹", "success")
self.root.after(0, lambda: self.stat_total.set(f"è¯»å–èŠ‚ç‚¹ï¼š{len(raw_nodes)}"))
# ========== æ­¥éª¤2: å»é‡ ==========
self.log("ğŸ” æ­¥éª¤2: æ­£åœ¨å»é‡æ£€æµ‹...")
self.progress.configure(value=20),
self.lbl_percent.config(text="20%")
if self.opt_dedup.get():
unique_nodes = list(dict.fromkeys(raw_nodes))
dup_count = len(raw_nodes) - len(unique_nodes)
self.log(f"âœ… æ­¥éª¤2å®Œæˆ: å»é‡å‰ {len(raw_nodes)} ä¸ª, å»é‡å {len(unique_nodes)} ä¸ª, å‰”é™¤ {dup_count} ä¸ªé‡å¤èŠ‚ç‚¹", "success")
unique_nodes = raw_nodes
dup_count = 0
self.log(f"â­ æ­¥éª¤2å®Œæˆ: è·³è¿‡å»é‡, ä¿æŒ {len(unique_nodes)} ä¸ªèŠ‚ç‚¹", "success")
self.root.after(0, lambda: self.stat_dup.set(f"å»é‡èŠ‚ç‚¹ï¼š{dup_count}"))
# ========== æ­¥éª¤3: æ·»åŠ å›½å®¶ç å‰ç¼€ ==========
tagged_nodes = []
self.log("ğŸŒ æ­¥éª¤3: æ­£åœ¨æ·»åŠ å›½å®¶ç å‰ç¼€...")
self.progress.configure(value=30),
self.lbl_percent.config(text="30%")
reader = geoip2.database.Reader(db_p)
country_counter = {}
for i, line in enumerate(unique_nodes):
break
if i % 10 == 0:
progress = 30 + int((i / len(unique_nodes)) * 20)
self.root.after(0, lambda p=progress: [
self.progress.configure(value=p),
self.lbl_percent.config(text=f"{p}%")
if "vmess://" in line:
decoded = base64.b64decode(line[8:] + '===').decode('utf-8')
config = json.loads(decoded)
host = config.get("add", "")
u = urlparse(line)
host = u.hostname
if host:
tag = self.get_country_tag(host, reader)
country_code = tag[:2].lower()
if country_code not in country_counter:
country_counter[country_code] = 1
country_counter[country_code] += 1
seq = country_counter[country_code]
prefix = f"{tag}_{seq:03d}_ywy"
config["ps"] = prefix
new_line = "vmess://" + base64.b64encode(json.dumps(config).encode()).decode()
base_url = line.split('#')[0]
new_line = f"{base_url}#{prefix}"
new_line = line
tagged_nodes.append(new_line)
if reader:
reader.close()
self.log(f"âœ… æ­¥éª¤3å®Œæˆ: å·²ä¸º {len(tagged_nodes)} ä¸ªèŠ‚ç‚¹æ·»åŠ å›½å®¶ç å‰ç¼€", "success")
tagged_nodes = unique_nodes
self.log("â­ æ­¥éª¤3å®Œæˆ: è·³è¿‡å›½å®¶ç å‰ç¼€", "success")
# ========== æ­¥éª¤4: ç”Ÿæˆall_nodes.txt ==========
self.log("ğŸ’¾ æ­¥éª¤4: æ­£åœ¨ç”Ÿæˆall_nodes.txt...")
self.progress.configure(value=60),
self.lbl_percent.config(text="60%")
if selected_files.get("all_nodes.txt") and tagged_nodes:
with open(os.path.join(out_folder, "all_nodes.txt"), "w", encoding="utf-8") as f:
f.write("\n".join(tagged_nodes))
self.log(f"âœ… æ­¥éª¤4å®Œæˆ: å·²ç”Ÿæˆ all_nodes.txt, åŒ…å« {len(tagged_nodes)} ä¸ªèŠ‚ç‚¹", "success")
# ========== æ­¥éª¤5: çœŸè¿æ¥æµ‹è¯• ==========
if self.opt_test.get():
self.log("âš¡ æ­¥éª¤5: æ­£åœ¨è¿›è¡ŒçœŸè¿æ¥æµ‹è¯•...")
self.progress.configure(value=70),
self.lbl_percent.config(text="70%")
self.test_nodes(tagged_nodes, db_p, selected_files, out_folder)
self.log("â­ æ­¥éª¤5å®Œæˆ: è·³è¿‡çœŸè¿æ¥æµ‹è¯•", "success")
reader = geoip2.database.Reader(db_p) if self.opt_tag.get() else None
for line in tagged_nodes:
node_info = self.create_node_info(line, reader, is_valid=True)
if node_info:
self.valid_nodes.append(node_info)
if not self.stop_requested:
self.finalize_process(selected_files, out_folder, 0)
self.log(f"ğŸ’¥ è¿è¡Œå¼‚å¸¸: {e}", "error")
import traceback
self.log(f"ğŸ’¥ å¼‚å¸¸è¯¦æƒ…: {traceback.format_exc()}", "error")
def test_nodes(self, nodes, db_p, selected_files, out_folder):
"""æµ‹è¯•èŠ‚ç‚¹è¿æ¥æ€§"""
total_count = len(nodes)
tested_count = 0
fail_count = 0
self.executor = concurrent.futures.ThreadPoolExecutor(max_workers=32)
futures = []
for node in nodes:
future = self.executor.submit(self.test_single_node, node, reader)
futures.append(future)
for future in concurrent.futures.as_completed(futures):
if self.stop_requested or self.force_stop:
for f in futures:
f.cancel()
self.log("â¹ ä»»åŠ¡å·²æ‰‹åŠ¨åœæ­¢", "warning")
with self.pause_cond:
while self.is_paused and not self.stop_requested:
self.pause_cond.wait(timeout=0.5)
tested_count += 1
result = future.result()
if result and result.get("valid", False):
self.valid_nodes.append(result)
fail_count += 1
progress = 70 + int((tested_count / total_count) * 20)
self.root.after(0, lambda p=progress, fc=fail_count, vn=len(self.valid_nodes): [
self.lbl_percent.config(text=f"{p}%"),
self.stat_fail.set(f"æµ‹è¯•å‰”é™¤ï¼š{fc}"),
self.stat_final.set(f"æœ‰æ•ˆèŠ‚ç‚¹ï¼š{vn}")
self.log(f"âš ï¸ æµ‹è¯•å¼‚å¸¸: {e}", "warning")
if self.executor:
self.executor.shutdown(wait=False, cancel_futures=True)
self.executor.shutdown(wait=True)
if not self.stop_requested and not self.force_stop:
self.log(f"âœ… æ­¥éª¤5å®Œæˆ: æµ‹è¯• {total_count} ä¸ªèŠ‚ç‚¹, æœ‰æ•ˆ {len(self.valid_nodes)} ä¸ª, å¤±è´¥ {fail_count} ä¸ª", "success")
self.finalize_process(selected_files, out_folder, fail_count)
self.log("â¹ ä»»åŠ¡å·²æå‰ç»ˆæ­¢", "warning")
self.root.after(0, lambda: self.log("âœ… æ‰‹åŠ¨åœæ­¢æˆåŠŸ", "success"))
def test_single_node(self, line, reader):
return None
port = config.get("port", 443)
node_type = "vmess"
port = u.port or 443
node_type = u.scheme
if not host:
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.settimeout(3)
sock.connect((host, port))
sock.close()
tag = "unknown"
return {
"raw": line,
"host": host,
"port": port,
"tag": tag,
"type": node_type,
"valid": True
except (socket.timeout, ConnectionRefusedError, OSError):
except Exception:
def create_node_info(self, line, reader, is_valid=False):
config = None
"config": config,
"valid": is_valid
def finalize_process(self, selected_files, out_folder, fail_count):
"""å®Œæˆå¤„ç†æµç¨‹"""
self.log("â¹ ä»»åŠ¡å·²æ‰‹åŠ¨åœæ­¢ï¼Œè·³è¿‡æœ€ç»ˆå¤„ç†", "warning")
# ========== æ­¥éª¤6: ç”Ÿæˆvalid_nodes.txt ==========
self.log("ğŸ’¾ æ­¥éª¤6: æ­£åœ¨ç”Ÿæˆvalid_nodes.txt...")
self.progress.configure(value=90),
self.lbl_percent.config(text="90%")
if selected_files.get("valid_nodes.txt") and self.valid_nodes:
with open(os.path.join(out_folder, "valid_nodes.txt"), "w", encoding="utf-8") as f:
for node in self.valid_nodes:
f.write(node["raw"] + "\n")
self.log(f"âœ… æ­¥éª¤6å®Œæˆ: å·²ç”Ÿæˆ valid_nodes.txt, åŒ…å« {len(self.valid_nodes)} ä¸ªæœ‰æ•ˆèŠ‚ç‚¹", "success")
# ========== æ­¥éª¤7: ç”Ÿæˆvalid_nodes.yaml ==========
self.log("ğŸ“„ æ­¥éª¤7: æ­£åœ¨ç”Ÿæˆvalid_nodes.yaml...")
if selected_files.get("valid_nodes.yaml") and self.valid_nodes:
self.generate_yaml_file(out_folder)
self.log(f"âœ… æ­¥éª¤7å®Œæˆ: å·²ç”Ÿæˆ valid_nodes.yaml", "success")
# ========== æ­¥éª¤8: æ£€æµ‹GeminièŠ‚ç‚¹å¹¶ç”Ÿæˆgemini.txt ==========
self.log("ğŸ¤– æ­¥éª¤8: æ­£åœ¨æ£€æµ‹Geminiå¯ç”¨èŠ‚ç‚¹...")
if selected_files.get("gemini.txt") and self.valid_nodes:
self.test_gemini_nodes(out_folder)
self.stat_final.set(f"æœ‰æ•ˆèŠ‚ç‚¹ï¼š{len(self.valid_nodes)}"),
self.progress.configure(value=100),
self.lbl_percent.config(text="100%"),
self.enable_btns(),
self.log("ğŸ‰ æ‰€æœ‰ä»»åŠ¡å®Œæˆ!", "success")
self.auto_cleanup()
self.log(f"ğŸ’¥ æœ€ç»ˆå¤„ç†å¼‚å¸¸: {e}", "error")
def generate_yaml_file(self, folder):
"""ç”ŸæˆYAMLé…ç½®æ–‡ä»¶"""
proxies = []
if node["type"] == "vmess" and node["config"]:
proxy = {
"name": node["config"].get("ps", f"{node['tag']}_node"),
"type": "vmess",
"server": node["host"],
"port": node["port"],
"uuid": node["config"].get("id", ""),
"alterId": node["config"].get("aid", 0),
"cipher": "auto",
"network": node["config"].get("net", "tcp"),
"tls": node["config"].get("tls", "") == "tls"
proxies.append(proxy)
yaml_content = {
"proxies": proxies,
"proxy-groups": [
{
"name": "è‡ªåŠ¨é€‰æ‹©",
"type": "url-test",
"proxies": [p["name"] for p in proxies],
"url": "http://www.gstatic.com/generate_204",
"interval": 300
},
"name": "æ‰‹åŠ¨é€‰æ‹©",
"type": "select",
"proxies": [p["name"] for p in proxies]
],
"rules": [
"DOMAIN-SUFFIX,google.com,è‡ªåŠ¨é€‰æ‹©",
"DOMAIN-SUFFIX,github.com,è‡ªåŠ¨é€‰æ‹©",
"DOMAIN-KEYWORD,gstatic,è‡ªåŠ¨é€‰æ‹©",
"GEOIP,CN,DIRECT",
"MATCH,è‡ªåŠ¨é€‰æ‹©"
]
with open(os.path.join(folder, "valid_nodes.yaml"), "w", encoding="utf-8") as f:
yaml.dump(yaml_content, f, allow_unicode=True, default_flow_style=False)
self.log(f"âŒ ç”ŸæˆYAMLæ–‡ä»¶å¤±è´¥: {e}", "error")
def test_gemini_nodes(self, folder):
"""æ£€æµ‹Geminiå¯ç”¨èŠ‚ç‚¹"""
self.log("ğŸ” æ­£åœ¨æ£€æµ‹Geminiå¯ç”¨èŠ‚ç‚¹...")
gemini_nodes = []
tag = node["tag"].lower()
if not tag.startswith("cn"):
country_code = tag[:2].lower() if len(tag) >= 2 else "un"
gemini_config = node["config"].copy()
gemini_config["ps"] = f"{tag}_gemini_{seq:03d}_ywy"
encoded_config = base64.b64encode(json.dumps(gemini_config).encode()).decode()
gemini_line = f"vmess://{encoded_config}"
gemini_nodes.append(gemini_line)
self.log(f"âœ… Geminiå¯ç”¨: {node['host']} -> {gemini_config['ps']}", "success")
if gemini_nodes:
with open(os.path.join(folder, "gemini.txt"), "w", encoding="utf-8") as f:
f.write("\n".join(gemini_nodes))
self.log(f"âœ… å·²ç”Ÿæˆ gemini.txt, åŒ…å« {len(gemini_nodes)} ä¸ªGeminiä¸“ç”¨èŠ‚ç‚¹", "success")
self.root.after(0, lambda: self.stat_gemini.set(f"GeminièŠ‚ç‚¹ï¼š{len(gemini_nodes)}"))
self.log("âš ï¸ æœªæ‰¾åˆ°å¯ç”¨çš„GeminièŠ‚ç‚¹", "warning")
self.log(f"âŒ Geminiæ£€æµ‹å¤±è´¥: {e}", "error")
# ========== UIæ§åˆ¶æ–¹æ³• ==========
def reset_ui(self):
self.unlock_all_ui()
self.btn_pause.config(state="disabled", text="â¸ æš‚åœ")
self.btn_stop.config(state="disabled", text="â¹ ç»ˆæ­¢")
self.progress.configure(value=0); self.lbl_percent.config(text="0%")
self.stop_all_threads()
def lock_all_ui(self):
for b in self.all_interactive_btns:
try: b.config(state="disabled")
for b in self.file_btns_refs:
self.btn_start.config(state="disabled")
def unlock_all_ui(self):
try: b.config(state="normal")
self.btn_start.config(state="normal")
def enable_btns(self):
self.btn_open_folder.config(state="normal")
self.btn_push_all.config(state="normal")
def toggle_pause(self):
self.is_paused = not self.is_paused
self.btn_pause.config(text="â–¶ ç»§ç»­" if self.is_paused else "â¸ æš‚åœ")
self.log("â¸ ä»»åŠ¡å·²æš‚åœ" if self.is_paused else "â–¶ ä»»åŠ¡ç»§ç»­è¿è¡Œ", "warning")
with self.pause_cond: self.pause_cond.notify_all()
def on_stop_click(self):
"""åœæ­¢ä»»åŠ¡"""
self.stop_requested = True
self.force_stop = True
self.btn_stop.config(text="åœæ­¢ä¸­", state="disabled")
self.btn_pause.config(state="disabled")
self.log("â¹ æ­£åœ¨ç»ˆæ­¢ä»»åŠ¡...", "warning")
self.pause_cond.notify_all()
self.log("ğŸ›‘ æ‰‹åŠ¨åœæ­¢è¯·æ±‚å·²å‘é€...", "warning")
self.root.after(100, self.reset_ui)
self.root.after(200, lambda: self.log("âœ… æ‰‹åŠ¨åœæ­¢æˆåŠŸï¼", "success"))
def stop_all_threads(self):
"""åœæ­¢æ‰€æœ‰åå°çº¿ç¨‹"""
def refresh_file_status(self):
p_node, p_db = self.ent_node.get().strip(), self.ent_db.get().strip()
if os.path.exists(p_node):
mtime = os.path.getmtime(p_node)
ver = datetime.fromtimestamp(mtime).strftime('%Y%m%d.%H%M')
self.lbl_node_info.config(text=f"âœ… èŠ‚ç‚¹å°±ç»ª (Ver: {ver})", foreground="#28a745")
self.lbl_node_info.config(text="âŒ ç¼ºå¤± nodes/nodes.txt", foreground="#dc3545")
if days > 7:
self.lbl_db_info.config(text=f"â³ IPåº“å·²è¿‡æœŸ ({int(days)}å¤©)ï¼Œè¯·ç‚¹å‡»è¿œç¨‹æ›´æ–°", foreground="#fd7e14")
self.lbl_db_info.config(text=f"âœ… IPåº“å·²è½½å…¥ (Ver: {ver})", foreground="#28a745")
self.lbl_db_info.config(text="âŒ ç¼ºå¤± GeoLite æ•°æ®åº“", foreground="#dc3545")
def select_nodes(self):
f = filedialog.askopenfilename(initialdir=NODES_DIR, filetypes=[("æ–‡æœ¬", "*.txt")])
if f:
self.ent_node.delete(0, tk.END)
self.ent_node.insert(0, f)
self.save_config()
def select_db(self):
f = filedialog.askopenfilename(initialdir=GEO_DIR, filetypes=[("GeoIP", "*.mmdb")])
self.ent_db.delete(0, tk.END)
self.ent_db.insert(0, f)
def load_config(self):
self.ent_node.insert(0, DEFAULT_NODES)
self.ent_db.insert(0, DEFAULT_MMDB)
if os.path.exists(CONFIG_FILE):
with open(CONFIG_FILE, "r", encoding="utf-8") as f:
c = json.load(f)
self.source_mode.set(c.get("mode", 0))
if c.get("input"):
self.ent_node.insert(0, c.get("input"))
if c.get("db"):
self.ent_db.insert(0, c.get("db"))
self.v2rayn_path.set(c.get("v2_p", ""))
self.clash_path.set(c.get("cl_p", ""))
default_appbox = os.path.join(os.path.dirname(BASE_DIR), "AI BOX")
self.appbox_path.set(c.get("appbox_p", default_appbox))
self.sub_url.set(c.get("sub_url", ""))
self.db_url.set(c.get("db_url", ""))
self.sub_sources.set(c.get("sub_sources", os.path.join(NODES_DIR, "github_nodes.txt")))
self.g_repo.set(c.get("g_repo", ""))
self.g_token.set(c.get("g_token", ""))
self.gh_repo.set(c.get("gh_repo", ""))
self.gh_token.set(c.get("gh_token", ""))
self.log(f"âš ï¸ é…ç½®æ–‡ä»¶åŠ è½½å¤±è´¥: {e}", "warning")
def save_config(self, *args):
c = {
"input": self.ent_node.get(),
"db": self.ent_db.get(),
"mode": self.source_mode.get(),
"sub_url": self.sub_url.get(),
"db_url": self.db_url.get(),
"sub_sources": self.sub_sources.get(),
"g_repo": self.g_repo.get(),
"g_token": self.g_token.get(),
"gh_repo": self.gh_repo.get(),
"gh_token": self.gh_token.get(),
"v2_p": self.v2rayn_path.get(),
"cl_p": self.clash_path.get(),
"appbox_p": self.appbox_path.get()
with open(CONFIG_FILE, "w", encoding="utf-8") as f:
json.dump(c, f, indent=4)
self.log(f"âš ï¸ é…ç½®æ–‡ä»¶ä¿å­˜å¤±è´¥: {e}", "warning")
def copy_act(self, fn, btn):
"""å¤åˆ¶æ–‡ä»¶å†…å®¹åˆ°å‰ªè´´æ¿"""
file_path = os.path.join(self.current_out_folder, fn)
with open(file_path, 'r', encoding='utf-8') as f:
self.root.clipboard_clear()
self.root.clipboard_append(f.read())
self.log(f"ğŸ“‹ å·²å¤åˆ¶ {fn}", "success")
btn.config(text="âœ…")
self.root.after(1000, lambda: btn.config(text="å¤åˆ¶"))
self.log(f"âŒ å¤åˆ¶å¤±è´¥: {e}", "error")
btn.config(text="âŒ")
def open_settings(self):
"""æ‰“å¼€è®¾ç½®ä¸­å¿ƒ"""
win = tk.Toplevel(self.root)
win.title("é…ç½®ä¸­å¿ƒ")
win.grab_set()
m = ttk.Frame(win, padding=20)
m.pack(fill="both", expand=True)
def add_entry(parent, label, var, is_path=False, secret=False):
ttk.Label(parent, text=label).pack(anchor="w", pady=(8,2))
row = ttk.Frame(parent)
row.pack(fill="x")
ent = ttk.Entry(row, textvariable=var, show="*" if secret else "", width=60)
ent.pack(side="left", fill="x", expand=True)
if is_path:
ttk.Button(row, text="æµè§ˆ", command=lambda: self.select_exe(var)).pack(side="right", padx=(5,0))
add_entry(m, "ğŸ”— èŠ‚ç‚¹æ–‡ä»¶è®¢é˜… URL:", self.sub_url)
add_entry(m, "ğŸŒ IPåº“æ–‡ä»¶ä¸‹è½½ URL:", self.db_url)
add_entry(m, "ğŸ“‹ è®¢é˜…æºç¾¤æ–‡ä»¶:", self.sub_sources, is_path=True)
add_entry(m, "ğŸ“¦ Gitee ä»“åº“ (user/repo):", self.g_repo)
add_entry(m, "ğŸ”‘ Gitee Token:", self.g_token, secret=True)
add_entry(m, "ğŸ“¦ GitHub ä»“åº“ (user/repo):", self.gh_repo)
add_entry(m, "ğŸ”‘ GitHub Token:", self.gh_token, secret=True)
add_entry(m, "ğŸ“¦ AIç›’å­è·¯å¾„:", self.appbox_path, is_path=True)
add_entry(m, "ğŸ“‚ v2rayN è·¯å¾„:", self.v2rayn_path, is_path=True)
add_entry(m, "ğŸ“‚ ClashV è·¯å¾„:", self.clash_path, is_path=True)
ttk.Button(m, text="ğŸ’¾ ä¿å­˜å¹¶åº”ç”¨", command=lambda: [self.save_config(), win.destroy()]).pack(pady=20)
def select_exe(self, var):
"""é€‰æ‹©å¯æ‰§è¡Œæ–‡ä»¶"""
f = filedialog.askopenfilename(filetypes=[("EXE", "*.exe"), ("æ‰€æœ‰æ–‡ä»¶", "*.*")])
var.set(f)
def open_appbox(self):
"""æ‰“å¼€AIç›’å­"""
p = self.appbox_path.get()
if os.path.exists(p):
os.startfile(p)
self.log("âŒ AIç›’å­è·¯å¾„ä¸å­˜åœ¨", "error")
def open_v2rayn(self):
p = self.v2rayn_path.get()
if os.path.exists(p): os.startfile(p)
def open_clash(self):
p = self.clash_path.get()
def open_current_folder(self):
if self.current_out_folder: os.startfile(self.current_out_folder)
def open_url(self, plat):
repo = self.g_repo.get() if plat == "gitee" else self.gh_repo.get()
if repo: webbrowser.open(f"https://{'gitee.com' if plat=='gitee' else 'github.com'}/{repo}")
def auto_cleanup(self):
"""è‡ªåŠ¨æ¸…ç†æ—§æ–‡ä»¶å¤¹"""
all_dirs = [os.path.join(NODES_DIR, d) for d in os.listdir(NODES_DIR) if os.path.isdir(os.path.join(NODES_DIR, d))]
all_dirs.sort(key=lambda x: os.path.getmtime(x), reverse=True)
if len(all_dirs) > 10:
for old_dir in all_dirs[10:]:
shutil.rmtree(old_dir)
self.log(f"âš ï¸ è‡ªåŠ¨æ¸…ç†å¼‚å¸¸: {e}", "warning")
def show_about(self):
about_text = (
f"ç¨‹åºåç§°: {APP_NAME}\n"
f"â—å½“å‰ç‰ˆæœ¬: {VERSION}\n"
f"â—æ ¸å¿ƒæ¶æ„ï¼šPython 3.x (Concurrent Pool)\n"
f"â—IPæ•°æ®åº“ï¼šGeoLite2-Country.mmdb \n\n"
"æ ¸å¿ƒåŠŸèƒ½è¯´æ˜:\n"
f"1. æ”¯æŒä¸»æµåè®®ï¼šè‡ªåŠ¨è¯†åˆ«/è§£æ VMessã€VLESSã€SS é“¾æ¥ã€‚\n"
f"2. åœ°ç†å®šä½ï¼šé›†æˆ GeoIP2 æ•°æ®åº“ï¼Œå®ç°æœåŠ¡å™¨ç‰©ç†ä½ç½®æ ‡è®°ã€‚\n"
f"3. æ™ºèƒ½å‘½åï¼šæŒ‰ [å›½å®¶ä»£ç _åºå·] è‡ªåŠ¨é‡å‘½åèŠ‚ç‚¹åˆ«åã€‚\n"
f"4. è‡ªåŠ¨é‡‡é›†ä¼˜è´¨GitHubè®¢é˜…æº\n"
f"5. å¤šçº¿ç¨‹èŠ‚ç‚¹å»¶è¿Ÿæµ‹é€Ÿï¼šåŸºäº Socket æ¡æ‰‹çœŸè¿æ¥æµ‹è¯•ï¼Œè¿‡æ»¤å¤±æ•ˆèŠ‚ç‚¹ã€‚\n"
f"6. è‡ªåŠ¨ç­›é€‰é€‚ç”¨äºGeminiã€ChatGPTçš„èŠ‚ç‚¹å¹¶ä¿å­˜ã€‚\n"
f"7. è‡ªåŠ¨ç”ŸæˆBace64åŠ å¯†å‹JPGè®¢é˜…æ–‡ä»¶ï¼Œyamlè®¢é˜…æ–‡ä»¶\n"
f"8 è‡ªåŠ¨åŒ– Gitee/Github è®¢é˜…æ¨é€ã€‚\n"
f"9. å¿«æ·æ‰“å¼€ä¸»æµä»£ç†å®¢æˆ·ç«¯v2rayNã€Clash V\n\n"
f"ç‰ˆæƒæ‰€æœ‰ Â© 2026 å¤œæœªå¤® - AI Box"
)
messagebox.showinfo("å…³äºèŠ‚ç‚¹ç›’å­", about_text)
def remote_collect_nodes(self):
"""è¿œç¨‹é‡‡é›†èŠ‚ç‚¹"""
self.log("ğŸŒ å¯åŠ¨è¿œç¨‹é‡‡é›†èŠ‚ç‚¹...")
self.btn_sub_upd.config(text="åœæ­¢é‡‡é›†", state="normal", command=self.stop_collection)
threading.Thread(target=self._remote_collect_thread, daemon=True).start()
def _remote_collect_thread(self):
"""è¿œç¨‹é‡‡é›†çº¿ç¨‹"""
is_proxy_enabled = self.check_proxy_status()
self.log(f"ğŸŒ ä»£ç†çŠ¶æ€: {'å·²å¯ç”¨' if is_proxy_enabled else 'æœªå¯ç”¨'}")
sources_file = self.sub_sources.get()
if not os.path.exists(sources_file):
sources_file = os.path.join(NODES_DIR, "github_nodes.txt")
self.log("âŒ è®¢é˜…æºæ–‡ä»¶ä¸å­˜åœ¨", "error")
self.finish_collection()
self.log(f"ğŸ“– è¯»å–è®¢é˜…æº: {sources_file}")
with open(sources_file, 'r', encoding='utf-8') as f:
urls = [line.strip() for line in f if line.strip()]
self.log(f"ğŸ“Š å‘ç° {len(urls)} ä¸ªè®¢é˜…æº")
all_nodes = []
completed = 0
total = len(urls)
for url in urls:
if hasattr(self, 'stop_collection_flag') and self.stop_collection_flag:
self.log("â¹ é‡‡é›†å·²åœæ­¢", "warning")
self.log(f"â¬‡ï¸ ä¸‹è½½è®¢é˜…: {url[:50]}...")
proxies = None
if is_proxy_enabled:
proxies = {
'http': 'http://127.0.0.1:7890',
'https': 'http://127.0.0.1:7890'
headers = {
'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
response = requests.get(url, timeout=60, proxies=proxies, headers=headers)
response.raise_for_status()
content = response.text
# å¤„ç†jpgæ–‡ä»¶è®¢é˜…
if url.lower().endswith('.jpg') or url.lower().endswith('.jpeg'):
self.log(f"ğŸ” æ£€æµ‹åˆ°å›¾ç‰‡æ ¼å¼è®¢é˜…æºï¼Œå°è¯•è§£æ...", "warning")
nodes = self.extract_nodes_from_content(content, url)
nodes = self.parse_subscription_content(content)
self.log(f"âœ… è§£æåˆ° {len(nodes)} ä¸ªèŠ‚ç‚¹", "success")
all_nodes.extend(nodes)
self.log(f"âŒ ä¸‹è½½å¤±è´¥: {url[:30]}... - {str(e)[:50]}", "error")
completed += 1
progress = int((completed / total) * 100)
if all_nodes:
unique_nodes = list(dict.fromkeys(all_nodes))
self.log(f"ğŸ“Š é‡‡é›†å®Œæˆ: æ€»å…± {len(all_nodes)} ä¸ªèŠ‚ç‚¹ï¼Œå»é‡å {len(unique_nodes)} ä¸ª", "success")
nodes_file = DEFAULT_NODES
nodes_text = '\n'.join(unique_nodes)
with open(nodes_file, 'w', encoding='utf-8') as f:
f.write(nodes_text)
self.log(f"ğŸ’¾ å·²ä¿å­˜åˆ°: {nodes_file}", "success")
self.root.after(0, lambda: self.ent_node.delete(0, tk.END) or self.ent_node.insert(0, nodes_file))
self.log(f"ğŸ’¥ é‡‡é›†å¼‚å¸¸: {e}", "error")
def extract_nodes_from_content(self, content, url):
"""ä»å†…å®¹ä¸­æå–èŠ‚ç‚¹"""
nodes = []
# å°è¯•ç›´æ¥è§£ç base64
decoded = base64.b64decode(content).decode('utf-8')
nodes = [line.strip() for line in decoded.split('\n') if line.strip()]
if nodes:
return nodes
# æŸ¥æ‰¾å¯èƒ½çš„base64å­—ç¬¦ä¸²
base64_pattern = r'[A-Za-z0-9+/=]{20,}'
matches = re.findall(base64_pattern, content)
for match in matches:
decoded = base64.b64decode(match).decode('utf-8')
if 'vmess://' in decoded or 'ss://' in decoded or 'trojan://' in decoded:
lines = [line.strip() for line in decoded.split('\n') if line.strip()]
nodes.extend(lines)
self.log(f"ğŸ” ä»base64å­—ç¬¦ä¸²è§£æåˆ° {len(lines)} ä¸ªèŠ‚ç‚¹", "success")
continue
# å¦‚æœè¿˜æ²¡æœ‰æ‰¾åˆ°ï¼Œå°è¯•ç›´æ¥æŒ‰è¡Œåˆ†å‰²
if not nodes:
lines = [line.strip() for line in content.split('\n') if line.strip()]
for line in lines:
if 'vmess://' in line or 'ss://' in line or 'trojan://' in line:
nodes.append(line)
self.log(f"âŒ è§£æå†…å®¹å¤±è´¥: {str(e)[:50]}", "error")
def parse_subscription_content(self, content):
"""è§£æè®¢é˜…å†…å®¹"""
# æ£€æŸ¥æ˜¯å¦æ˜¯base64ç¼–ç 
if not content.startswith(('vmess://', 'ss://', 'trojan://', 'proxies:')):
content = decoded
if content.startswith('vmess://') or content.startswith('ss://') or content.startswith('trojan://'):
nodes = [line.strip() for line in content.split('\n') if line.strip()]
elif content.startswith('proxies:'):
nodes = self.parse_yaml_content(content)
self.log(f"âŒ è§£æè®¢é˜…å†…å®¹å¤±è´¥: {e}", "error")
def parse_yaml_content(self, content):
"""è§£æYAMLå†…å®¹"""
data = yaml.safe_load(content)
if 'proxies' in data:
for proxy in data['proxies']:
if proxy.get('type') == 'vmess':
vmess_config = {
"v": "2",
"ps": proxy.get('name', ''),
"add": proxy.get('server', ''),
"port": proxy.get('port', 0),
"id": proxy.get('uuid', ''),
"aid": proxy.get('alterId', 0),
"net": proxy.get('network', 'tcp'),
"type": proxy.get('type', 'none'),
"host": proxy.get('servername', ''),
"path": proxy.get('ws-path', ''),
"tls": proxy.get('tls', '')
encoded = base64.b64encode(json.dumps(vmess_config).encode()).decode()
nodes.append(f"vmess://{encoded}")
def stop_collection(self):
"""åœæ­¢é‡‡é›†"""
self.stop_collection_flag = True
self.log("ğŸ›‘ æ­£åœ¨åœæ­¢é‡‡é›†...", "warning")
def finish_collection(self):
"""å®Œæˆé‡‡é›†"""
self.unlock_all_ui(),
self.btn_sub_upd.config(text="è¿œç¨‹é‡‡é›†", command=self.remote_collect_nodes),
if hasattr(self, 'stop_collection_flag'):
del self.stop_collection_flag
def push_all_files(self):
"""æ¨é€æ‰€æœ‰é€‰ä¸­çš„æ–‡ä»¶ - ä¿®å¤ç‰ˆæœ¬"""
self.log("ğŸš€ å¼€å§‹æ¨é€æ‰€æœ‰é€‰ä¸­çš„æ–‡ä»¶...")
selected = []
for file_name, var in self.file_vars.items():
if var.get():
selected.append(file_name)
if not selected:
self.log("âš ï¸ æ²¡æœ‰é€‰ä¸­ä»»ä½•æ–‡ä»¶", "warning")
self.log(f"ğŸ“¤ å‡†å¤‡æ¨é€ {len(selected)} ä¸ªæ–‡ä»¶", "success")
# é”å®šUIä½†ä¿æŒæ¨é€æŒ‰é’®å¯ç”¨
self.btn_push_all.config(text="æ¨é€ä¸­...", state="disabled")
threading.Thread(target=self._push_all_thread_fixed, args=(selected,), daemon=True).start()
def _push_all_thread_fixed(self, selected_files):
"""æ¨é€æ‰€æœ‰æ–‡ä»¶çš„çº¿ç¨‹ - ä¿®å¤ç‰ˆæœ¬"""
total = len(selected_files)
success_files = []
failed_files = []
for file_name in selected_files:
self.log("â¹ æ¨é€ä»»åŠ¡å·²æ‰‹åŠ¨åœæ­¢", "warning")
self.log(f"ğŸ“¤ æ­£åœ¨æ¨é€: {file_name}")
path = os.path.join(self.current_out_folder, file_name)
if not os.path.exists(path):
self.log(f"âŒ æ–‡ä»¶ä¸å­˜åœ¨: {file_name}", "error")
failed_files.append((file_name, "æ–‡ä»¶ä¸å­˜åœ¨"))
# è¯»å–æ–‡ä»¶å†…å®¹
with open(path, 'r', encoding='utf-8') as f:
content = f.read()
# é‡è¦ï¼šå¯¹å†…å®¹è¿›è¡Œbase64ç¼–ç ï¼ˆé˜²æ­¢è¢«ä»“åº“å±è”½ï¼‰
# è¿›è¡Œä¸€æ¬¡base64ç¼–ç ï¼ˆå¤§å¤šæ•°è®¢é˜…è½¯ä»¶éƒ½èƒ½è§£ç ä¸€å±‚base64ï¼‰
b64_content = base64.b64encode(content.encode()).decode('utf-8')
# å¦‚æœéœ€è¦åŒé‡ç¼–ç ï¼Œå¯ä»¥å¯ç”¨ä¸‹é¢çš„ä»£ç ï¼ˆæ›´å®‰å…¨ä½†éœ€è¦è®¢é˜…è½¯ä»¶æ”¯æŒåŒå±‚è§£ç ï¼‰
# b64_content = base64.b64encode(b64_content.encode()).decode('utf-8')
results = []
g_repo, g_token = self.g_repo.get(), self.g_token.get()
gh_repo, gh_token = self.gh_repo.get(), self.gh_token.get()
platform_results = {}
if g_token and g_repo:
ok, msg = self.api_call("Gitee", g_repo, g_token, b64_content, file_name)
results.append(ok)
platform_results["Gitee"] = ok
status = "æˆåŠŸ" if ok else f"å¤±è´¥: {msg}"
if ok:
self.log(f"â˜ï¸ [Gitee] {file_name} {status}", "success")
self.log(f"â˜ï¸ [Gitee] {file_name} {status}", "error")
if gh_token and gh_repo:
ok, msg = self.api_call("GitHub", gh_repo, gh_token, b64_content, file_name)
platform_results["GitHub"] = ok
self.log(f"â˜ï¸ [GitHub] {file_name} {status}", "success")
self.log(f"â˜ï¸ [GitHub] {file_name} {status}", "error")
final_success = any(results) if results else False
if final_success:
success_files.append(file_name)
self.log(f"âœ… {file_name} æ¨é€å®Œæˆ", "success")
failed_files.append((file_name, "æ‰€æœ‰å¹³å°æ¨é€å¤±è´¥"))
self.log(f"âŒ {file_name} æ¨é€å¤±è´¥", "error")
failed_files.append((file_name, str(e)))
self.log(f"âŒ æ¨é€å¤±è´¥ {file_name}: {e}", "error")
# ä»»åŠ¡å®Œæˆï¼Œæ˜¾ç¤ºç»Ÿè®¡ç»“æœ
if success_files:
self.log(f"ğŸ‰ æ¨é€æˆåŠŸ {len(success_files)} ä¸ªæ–‡ä»¶:", "success")
for f in success_files:
self.log(f"  âœ… {f}", "success")
if failed_files:
self.log(f"âš ï¸ æ¨é€å¤±è´¥ {len(failed_files)} ä¸ªæ–‡ä»¶:", "warning")
for f, reason in failed_files:
self.log(f"  âŒ {f}: {reason}", "error")
if success_files or failed_files:
self.log("ğŸ“¤ æ‰€æœ‰æ–‡ä»¶æ¨é€ä»»åŠ¡å®Œæˆ", "success" if not failed_files else "warning")
self.log(f"ğŸ’¥ æ¨é€è¿‡ç¨‹å‘ç”Ÿå¼‚å¸¸: {e}", "error")
failed_files.append(("æ¨é€ä»»åŠ¡", str(e)))
# æ— è®ºæˆåŠŸæˆ–å¤±è´¥ï¼Œéƒ½æ¢å¤UIçŠ¶æ€
self.btn_push_all.config(text="å…¨éƒ¨æ¨é€", state="normal"),
def manual_push(self, fn, btn):
"""æ‰‹åŠ¨æ¨é€å•ä¸ªæ–‡ä»¶ - ä¿®å¤ç‰ˆæœ¬"""
path = os.path.join(self.current_out_folder, fn)
self.log(f"âŒ æ¨é€å¤±è´¥ï¼šæ–‡ä»¶ {fn} ä¸å­˜åœ¨", "error")
btn.config(text="âŒ›..", state="disabled")
def _th():
with open(path, "r", encoding="utf-8", errors="ignore") as f:
ok, msg = self.api_call("Gitee", g_repo, g_token, b64_content, fn)
self.log(f"â˜ï¸ [Gitee] {fn} {status}", "success")
self.log(f"â˜ï¸ [Gitee] {fn} {status}", "error")
ok, msg = self.api_call("GitHub", gh_repo, gh_token, b64_content, fn)
self.log(f"â˜ï¸ [GitHub] {fn} {status}", "success")
self.log(f"â˜ï¸ [GitHub] {fn} {status}", "error")
self.root.after(0, lambda: btn.config(text="âœ…" if final_success else "âŒ"))
self.log(f"ğŸ’¥ æ¨é€è¿‡ç¨‹å¼‚å¸¸: {e}", "error")
self.root.after(0, lambda: btn.config(text="âŒ"))
self.root.after(2000, lambda: btn.config(text="æ¨é€", state="normal"))
threading.Thread(target=_th, daemon=True).start()
def api_call(self, plat, repo, token, cont, fn):
"""APIè°ƒç”¨ - æ”¯æŒbase64ç¼–ç å†…å®¹"""
if plat == "Gitee":
u = f"https://gitee.com/api/v5/repos/{repo}/contents/{fn}"
u = f"https://api.github.com/repos/{repo}/contents/{fn}"
headers = {"User-Agent": "Mozilla/5.0"}
if plat == "GitHub":
headers["Authorization"] = f"Bearer {token}"
headers["Accept"] = "application/vnd.github.v3+json"
params = {}
params = {"access_token": token}
r = requests.get(u, headers=headers, params=params, timeout=10)
sha = r.json().get("sha") if r.status_code == 200 else None
data = {
"message": f"update {fn} via NodeBOX {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
"content": cont,
"sha": sha
data["access_token"] = token
data["encoding"] = "base64"
if sha:
resp = requests.put(u, headers=headers, json=data, timeout=15)
resp = requests.post(u, headers=headers, json=data, timeout=15)
if resp.status_code in [200, 201]:
return True, "Success"
err_info = resp.json().get("message", resp.text[:100])
err_info = f"Status Code {resp.status_code}"
return False, err_info
return False, str(e)
def remote_sync_act(self, mode):
url = self.sub_url.get().strip() if mode == "nodes" else self.db_url.get().strip()
self.log(f"âš ï¸ æ— æ³•æ›´æ–°: æœªé…ç½® URL", "warning")
btn = self.btn_sub_upd if mode == "nodes" else self.btn_db_upd
btn.config(text="ä¸‹è½½ä¸­", state="disabled")
self.log(f"ğŸŒ æ­£åœ¨åŒæ­¥ {'èŠ‚ç‚¹' if mode=='nodes' else 'IPåº“'}...")
final_path = DEFAULT_NODES if mode == "nodes" else DEFAULT_MMDB
f.write(chunk); dl += len(chunk)
self.root.after(0, lambda v=p: [self.progress.configure(value=v), self.lbl_percent.config(text=f"{v}%")])
if mode == "db" and (".gz" in url or ".tar.gz" in url):
self.log("ğŸ“¦ æ­£åœ¨è‡ªåŠ¨è§£å‹æ•°æ®åº“...")
self.log(f"âœ… åŒæ­¥æˆåŠŸ: {os.path.basename(final_path)}", "success")
self.root.after(0, lambda: btn.config(text="âœ… å°±ç»ª"))
self.log(f"âŒ ä¸‹è½½å¤±è´¥: {e}", "error")
self.root.after(0, lambda: btn.config(text="âŒ å¤±è´¥"))
self.root.after(0, lambda: [self.progress.configure(value=0), self.lbl_percent.config(text="0%")])
self.root.after(2000, lambda: btn.config(text="è¿œç¨‹ä¸‹è½½", state="normal"))
def check_proxy_status(self):
"""æ£€æµ‹æœ¬æœºæ˜¯å¦ä½¿ç”¨ä»£ç†"""
response = requests.get("https://api.ipify.org?format=json", timeout=5)
public_ip = response.json().get("ip")
local_ip = socket.gethostbyname(socket.gethostname())
if public_ip != local_ip:
self.log(f"ğŸŒ æ£€æµ‹åˆ°å¯èƒ½ä½¿ç”¨ä»£ç†: æœ¬åœ°IP={local_ip}, å…¬ç½‘IP={public_ip}")
return True
return False
if __name__ == "__main__":
root = tk.Tk()
app = NodeboxGUI(root)
root.mainloop()